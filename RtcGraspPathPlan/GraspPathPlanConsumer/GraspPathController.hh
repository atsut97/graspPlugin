// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __GraspPathController_hh__
#define __GraspPathController_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





#ifndef __planGraspPath__
#define __planGraspPath__

class planGraspPath;
class _objref_planGraspPath;
class _impl_planGraspPath;

typedef _objref_planGraspPath* planGraspPath_ptr;
typedef planGraspPath_ptr planGraspPathRef;

class planGraspPath_Helper {
public:
  typedef planGraspPath_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_planGraspPath, planGraspPath_Helper> planGraspPath_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_planGraspPath,planGraspPath_Helper > planGraspPath_out;

#endif

// interface planGraspPath
class planGraspPath {
public:
  // Declarations for this interface type.
  typedef planGraspPath_ptr _ptr_type;
  typedef planGraspPath_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DblSeq3;

  class DblSeq3_var;

  class DblSeq3 : public _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 >  {
  public:
    typedef DblSeq3_var _var_type;
    inline DblSeq3() {}
    inline DblSeq3(const DblSeq3& _s)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > (_s) {}

    inline DblSeq3(_CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > (_len, _val, _rel) {}

  

    inline DblSeq3& operator = (const DblSeq3& _s) {
      _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSeq3_out;

  class DblSeq3_var {
  public:
    inline DblSeq3_var() : _pd_seq(0) {}
    inline DblSeq3_var(DblSeq3* _s) : _pd_seq(_s) {}
    inline DblSeq3_var(const DblSeq3_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSeq3(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSeq3_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSeq3_var& operator = (DblSeq3* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSeq3_var& operator = (const DblSeq3_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSeq3;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSeq3* operator -> () { return _pd_seq; }
    inline const DblSeq3* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSeq3& () const { return *_pd_seq; }
#else
    inline operator const DblSeq3& () const { return *_pd_seq; }
    inline operator DblSeq3& () { return *_pd_seq; }
#endif
      
    inline const DblSeq3& in() const { return *_pd_seq; }
    inline DblSeq3&       inout()    { return *_pd_seq; }
    inline DblSeq3*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSeq3* _retn() { DblSeq3* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSeq3_out;
    
  private:
    DblSeq3* _pd_seq;
  };

  class DblSeq3_out {
  public:
    inline DblSeq3_out(DblSeq3*& _s) : _data(_s) { _data = 0; }
    inline DblSeq3_out(DblSeq3_var& _s)
      : _data(_s._pd_seq) { _s = (DblSeq3*) 0; }
    inline DblSeq3_out(const DblSeq3_out& _s) : _data(_s._data) {}
    inline DblSeq3_out& operator = (const DblSeq3_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSeq3_out& operator = (DblSeq3* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSeq3*&()  { return _data; }
    inline DblSeq3*& ptr()       { return _data; }
    inline DblSeq3* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSeq3*& _data;

  private:
    DblSeq3_out();
    DblSeq3_out& operator=(const DblSeq3_var&);
  };

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DblSeq9;

  class DblSeq9_var;

  class DblSeq9 : public _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 >  {
  public:
    typedef DblSeq9_var _var_type;
    inline DblSeq9() {}
    inline DblSeq9(const DblSeq9& _s)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > (_s) {}

    inline DblSeq9(_CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > (_len, _val, _rel) {}

  

    inline DblSeq9& operator = (const DblSeq9& _s) {
      _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSeq9_out;

  class DblSeq9_var {
  public:
    inline DblSeq9_var() : _pd_seq(0) {}
    inline DblSeq9_var(DblSeq9* _s) : _pd_seq(_s) {}
    inline DblSeq9_var(const DblSeq9_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSeq9(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSeq9_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSeq9_var& operator = (DblSeq9* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSeq9_var& operator = (const DblSeq9_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSeq9;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSeq9* operator -> () { return _pd_seq; }
    inline const DblSeq9* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSeq9& () const { return *_pd_seq; }
#else
    inline operator const DblSeq9& () const { return *_pd_seq; }
    inline operator DblSeq9& () { return *_pd_seq; }
#endif
      
    inline const DblSeq9& in() const { return *_pd_seq; }
    inline DblSeq9&       inout()    { return *_pd_seq; }
    inline DblSeq9*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSeq9* _retn() { DblSeq9* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSeq9_out;
    
  private:
    DblSeq9* _pd_seq;
  };

  class DblSeq9_out {
  public:
    inline DblSeq9_out(DblSeq9*& _s) : _data(_s) { _data = 0; }
    inline DblSeq9_out(DblSeq9_var& _s)
      : _data(_s._pd_seq) { _s = (DblSeq9*) 0; }
    inline DblSeq9_out(const DblSeq9_out& _s) : _data(_s._data) {}
    inline DblSeq9_out& operator = (const DblSeq9_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSeq9_out& operator = (DblSeq9* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSeq9*&()  { return _data; }
    inline DblSeq9*& ptr()       { return _data; }
    inline DblSeq9* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSeq9*& _data;

  private:
    DblSeq9_out();
    DblSeq9_out& operator=(const DblSeq9_var&);
  };

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DblSeq;

  class DblSeq_var;

  class DblSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DblSeq_var _var_type;
    inline DblSeq() {}
    inline DblSeq(const DblSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DblSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DblSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DblSeq& operator = (const DblSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSeq_out;

  class DblSeq_var {
  public:
    inline DblSeq_var() : _pd_seq(0) {}
    inline DblSeq_var(DblSeq* _s) : _pd_seq(_s) {}
    inline DblSeq_var(const DblSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSeq_var& operator = (DblSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSeq_var& operator = (const DblSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSeq* operator -> () { return _pd_seq; }
    inline const DblSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSeq& () const { return *_pd_seq; }
#else
    inline operator const DblSeq& () const { return *_pd_seq; }
    inline operator DblSeq& () { return *_pd_seq; }
#endif
      
    inline const DblSeq& in() const { return *_pd_seq; }
    inline DblSeq&       inout()    { return *_pd_seq; }
    inline DblSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSeq* _retn() { DblSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSeq_out;
    
  private:
    DblSeq* _pd_seq;
  };

  class DblSeq_out {
  public:
    inline DblSeq_out(DblSeq*& _s) : _data(_s) { _data = 0; }
    inline DblSeq_out(DblSeq_var& _s)
      : _data(_s._pd_seq) { _s = (DblSeq*) 0; }
    inline DblSeq_out(const DblSeq_out& _s) : _data(_s._data) {}
    inline DblSeq_out& operator = (const DblSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSeq_out& operator = (DblSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSeq*&()  { return _data; }
    inline DblSeq*& ptr()       { return _data; }
    inline DblSeq* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSeq*& _data;

  private:
    DblSeq_out();
    DblSeq_out& operator=(const DblSeq_var&);
  };

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LngSeq;

  class LngSeq_var;

  class LngSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef LngSeq_var _var_type;
    inline LngSeq() {}
    inline LngSeq(const LngSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline LngSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline LngSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline LngSeq& operator = (const LngSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class LngSeq_out;

  class LngSeq_var {
  public:
    inline LngSeq_var() : _pd_seq(0) {}
    inline LngSeq_var(LngSeq* _s) : _pd_seq(_s) {}
    inline LngSeq_var(const LngSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LngSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LngSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LngSeq_var& operator = (LngSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LngSeq_var& operator = (const LngSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LngSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LngSeq* operator -> () { return _pd_seq; }
    inline const LngSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LngSeq& () const { return *_pd_seq; }
#else
    inline operator const LngSeq& () const { return *_pd_seq; }
    inline operator LngSeq& () { return *_pd_seq; }
#endif
      
    inline const LngSeq& in() const { return *_pd_seq; }
    inline LngSeq&       inout()    { return *_pd_seq; }
    inline LngSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LngSeq* _retn() { LngSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LngSeq_out;
    
  private:
    LngSeq* _pd_seq;
  };

  class LngSeq_out {
  public:
    inline LngSeq_out(LngSeq*& _s) : _data(_s) { _data = 0; }
    inline LngSeq_out(LngSeq_var& _s)
      : _data(_s._pd_seq) { _s = (LngSeq*) 0; }
    inline LngSeq_out(const LngSeq_out& _s) : _data(_s._data) {}
    inline LngSeq_out& operator = (const LngSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LngSeq_out& operator = (LngSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator LngSeq*&()  { return _data; }
    inline LngSeq*& ptr()       { return _data; }
    inline LngSeq* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LngSeq*& _data;

  private:
    LngSeq_out();
    LngSeq_out& operator=(const LngSeq_var&);
  };

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ULONG;

  typedef ::CORBA::ULong ULONG;
  typedef ::CORBA::ULong_out ULONG_out;

  enum MotionState { APROACH, BACKAWAY, CLOSING_GRIPPER, OPENING_GRIPPER, UP_HAND, DOWN_HAND /*, __max_MotionState=0xffffffff */ };
  typedef MotionState& MotionState_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MotionState;

  enum ObjectInputMode { CREATE_RECORD, REMOVE_RECORD, APPEAR, DISAPPEAR, SETPOS, SET_TOLERANCE /*, __max_ObjectInputMode=0xffffffff */ };
  typedef ObjectInputMode& ObjectInputMode_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObjectInputMode;

  struct ManipInfo {
    typedef _CORBA_ConstrType_Variable_Var<ManipInfo> _var_type;

    
    DblSeq pos;

    MotionState state;

    ::CORBA::Boolean leftArm;

    ::CORBA::Boolean rightArm;

    ::CORBA::Boolean leftGripper;

    ::CORBA::Boolean rightGripper;

    ::CORBA::Boolean waist;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ManipInfo::_var_type ManipInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ManipInfo,ManipInfo_var > ManipInfo_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ManipInfo;

  struct ObjectInfo {
    typedef _CORBA_ConstrType_Variable_Var<ObjectInfo> _var_type;

    
    DblSeq3 pos;

    DblSeq9 ori;

    ULONG objId;

    ::CORBA::String_member tagId;

    ::CORBA::Double tolerance;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ObjectInfo::_var_type ObjectInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ObjectInfo,ObjectInfo_var > ObjectInfo_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObjectInfo;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ManipInfoSeq;

  class ManipInfoSeq_var;

  class ManipInfoSeq : public _CORBA_Unbounded_Sequence< ManipInfo >  {
  public:
    typedef ManipInfoSeq_var _var_type;
    inline ManipInfoSeq() {}
    inline ManipInfoSeq(const ManipInfoSeq& _s)
      : _CORBA_Unbounded_Sequence< ManipInfo > (_s) {}

    inline ManipInfoSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ManipInfo > (_max) {}
    inline ManipInfoSeq(_CORBA_ULong _max, _CORBA_ULong _len, ManipInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ManipInfo > (_max, _len, _val, _rel) {}

  

    inline ManipInfoSeq& operator = (const ManipInfoSeq& _s) {
      _CORBA_Unbounded_Sequence< ManipInfo > ::operator=(_s);
      return *this;
    }
  };

  class ManipInfoSeq_out;

  class ManipInfoSeq_var {
  public:
    inline ManipInfoSeq_var() : _pd_seq(0) {}
    inline ManipInfoSeq_var(ManipInfoSeq* _s) : _pd_seq(_s) {}
    inline ManipInfoSeq_var(const ManipInfoSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ManipInfoSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ManipInfoSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ManipInfoSeq_var& operator = (ManipInfoSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ManipInfoSeq_var& operator = (const ManipInfoSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ManipInfoSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ManipInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ManipInfoSeq* operator -> () { return _pd_seq; }
    inline const ManipInfoSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ManipInfoSeq& () const { return *_pd_seq; }
#else
    inline operator const ManipInfoSeq& () const { return *_pd_seq; }
    inline operator ManipInfoSeq& () { return *_pd_seq; }
#endif
      
    inline const ManipInfoSeq& in() const { return *_pd_seq; }
    inline ManipInfoSeq&       inout()    { return *_pd_seq; }
    inline ManipInfoSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ManipInfoSeq* _retn() { ManipInfoSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ManipInfoSeq_out;
    
  private:
    ManipInfoSeq* _pd_seq;
  };

  class ManipInfoSeq_out {
  public:
    inline ManipInfoSeq_out(ManipInfoSeq*& _s) : _data(_s) { _data = 0; }
    inline ManipInfoSeq_out(ManipInfoSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ManipInfoSeq*) 0; }
    inline ManipInfoSeq_out(const ManipInfoSeq_out& _s) : _data(_s._data) {}
    inline ManipInfoSeq_out& operator = (const ManipInfoSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ManipInfoSeq_out& operator = (ManipInfoSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ManipInfoSeq*&()  { return _data; }
    inline ManipInfoSeq*& ptr()       { return _data; }
    inline ManipInfoSeq* operator->() { return _data; }

    inline ManipInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ManipInfoSeq*& _data;

  private:
    ManipInfoSeq_out();
    ManipInfoSeq_out& operator=(const ManipInfoSeq_var&);
  };


};

class _objref_planGraspPath :
  public virtual ::CORBA::Object,
  public virtual omniObjRef
{
public:
  void GraspPlanningStart(::planGraspPath::ULONG mode, const ::planGraspPath::DblSeq& begin, const ::planGraspPath::DblSeq& end, const char* robotId, const char* objectTagId, ::CORBA::Double resolution, ::planGraspPath::ManipInfoSeq_out trajectory, ::planGraspPath::ULONG& state);
  void ReleasePlanningStart(::planGraspPath::ULONG mode, const ::planGraspPath::DblSeq& begin, const ::planGraspPath::DblSeq& end, const char* robotId, const char* objectTagId, ::CORBA::Double resolution, ::planGraspPath::ManipInfoSeq_out trajectory, ::planGraspPath::ULONG& state);
  void SetStatusObject(::planGraspPath::ObjectInputMode mode, const ::planGraspPath::ObjectInfo& obj);

  inline _objref_planGraspPath()  { _PR_setobj(0); }  // nil
  _objref_planGraspPath(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_planGraspPath();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_planGraspPath(const _objref_planGraspPath&);
  _objref_planGraspPath& operator = (const _objref_planGraspPath&);
  // not implemented

  friend class planGraspPath;
};

class _pof_planGraspPath : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_planGraspPath() : _OMNI_NS(proxyObjectFactory)(planGraspPath::_PD_repoId) {}
  virtual ~_pof_planGraspPath();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_planGraspPath :
  public virtual omniServant
{
public:
  virtual ~_impl_planGraspPath();

  virtual void GraspPlanningStart(::planGraspPath::ULONG mode, const ::planGraspPath::DblSeq& begin, const ::planGraspPath::DblSeq& end, const char* robotId, const char* objectTagId, ::CORBA::Double resolution, ::planGraspPath::ManipInfoSeq_out trajectory, ::planGraspPath::ULONG& state) = 0;
  virtual void ReleasePlanningStart(::planGraspPath::ULONG mode, const ::planGraspPath::DblSeq& begin, const ::planGraspPath::DblSeq& end, const char* robotId, const char* objectTagId, ::CORBA::Double resolution, ::planGraspPath::ManipInfoSeq_out trajectory, ::planGraspPath::ULONG& state) = 0;
  virtual void SetStatusObject(::planGraspPath::ObjectInputMode mode, const ::planGraspPath::ObjectInfo& obj) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_planGraspPath;



class POA_planGraspPath :
  public virtual _impl_planGraspPath,
  public virtual ::PortableServer::ServantBase
{
public:
  virtual ~POA_planGraspPath();

  inline ::planGraspPath_ptr _this() {
    return (::planGraspPath_ptr) _do_this(::planGraspPath::_PD_repoId);
  }
};







#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const planGraspPath::DblSeq3& _s);
void operator<<=(::CORBA::Any& _a, planGraspPath::DblSeq3* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::DblSeq3*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::DblSeq3*& _sp);

void operator<<=(::CORBA::Any& _a, const planGraspPath::DblSeq9& _s);
void operator<<=(::CORBA::Any& _a, planGraspPath::DblSeq9* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::DblSeq9*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::DblSeq9*& _sp);

void operator<<=(::CORBA::Any& _a, const planGraspPath::DblSeq& _s);
void operator<<=(::CORBA::Any& _a, planGraspPath::DblSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::DblSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::DblSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const planGraspPath::LngSeq& _s);
void operator<<=(::CORBA::Any& _a, planGraspPath::LngSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::LngSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::LngSeq*& _sp);

inline void operator >>=(planGraspPath::MotionState _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (planGraspPath::MotionState& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= planGraspPath::DOWN_HAND) {
    _e = (planGraspPath::MotionState) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, planGraspPath::MotionState _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::MotionState& _s);

inline void operator >>=(planGraspPath::ObjectInputMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (planGraspPath::ObjectInputMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= planGraspPath::SET_TOLERANCE) {
    _e = (planGraspPath::ObjectInputMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, planGraspPath::ObjectInputMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::ObjectInputMode& _s);

extern void operator<<=(::CORBA::Any& _a, const planGraspPath::ManipInfo& _s);
extern void operator<<=(::CORBA::Any& _a, planGraspPath::ManipInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::ManipInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::ManipInfo*& _sp);

extern void operator<<=(::CORBA::Any& _a, const planGraspPath::ObjectInfo& _s);
extern void operator<<=(::CORBA::Any& _a, planGraspPath::ObjectInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::ObjectInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::ObjectInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const planGraspPath::ManipInfoSeq& _s);
void operator<<=(::CORBA::Any& _a, planGraspPath::ManipInfoSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath::ManipInfoSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const planGraspPath::ManipInfoSeq*& _sp);

void operator<<=(::CORBA::Any& _a, planGraspPath_ptr _s);
void operator<<=(::CORBA::Any& _a, planGraspPath_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, planGraspPath_ptr& _s);



inline void
planGraspPath::_marshalObjRef(::planGraspPath_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_GraspPathController
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_GraspPathController
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_GraspPathController
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_GraspPathController
#endif

#endif  // __GraspPathController_hh__

